{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, Input } from '@angular/core';\nimport { Validators, ReactiveFormsModule } from '@angular/forms';\nimport { FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { environment } from '../../../../environments/environment';\nlet ProductFormComponent = class ProductFormComponent {\n  constructor(fb, route, router, apiService, notificationService, authService) {\n    this.fb = fb;\n    this.route = route;\n    this.router = router;\n    this.apiService = apiService;\n    this.notificationService = notificationService;\n    this.authService = authService;\n    this.isEditMode = false;\n    this.isLoading = false;\n    this.isSaving = false;\n    this.masterSizes = [];\n    this.categories = [];\n    this.selectedCoverImage = null;\n    this.selectedImages = [];\n    this.existingCoverImage = null;\n    this.existingImages = [];\n    this.newColor = '';\n    this.productColors = [];\n    this.sizeRows = [];\n    this.uploadsBaseUrl = environment.apiUrl.replace('/api/v1', '') + '/uploads';\n    this.productForm = this.createProductForm();\n  }\n  ngOnInit() {\n    // Check admin access\n    if (!this.authService.isAuthenticated() || !this.authService.isAdmin()) {\n      this.router.navigate(['/login']);\n      return;\n    }\n    // Get product ID from route if not provided as input\n    const routeId = this.route.snapshot.paramMap.get('id');\n    if (routeId && !this.productId) {\n      this.productId = routeId;\n    }\n    this.loadCategories();\n    this.loadMasterSizes();\n    if (this.productId) {\n      this.isEditMode = true;\n      this.loadProduct(this.productId);\n    }\n  }\n  createProductForm() {\n    return this.fb.group({\n      title: ['', [Validators.required, Validators.minLength(3)]],\n      description: ['', [Validators.required, Validators.minLength(5)]],\n      price: [0, [Validators.required, Validators.min(0)]],\n      priceAfterDiscount: [0, [Validators.min(0)]],\n      category: ['', [Validators.required]]\n    });\n  }\n  loadProduct(id) {\n    this.isLoading = true;\n    this.apiService.getById('/product', id).subscribe({\n      next: response => {\n        const product = response.data;\n        this.productForm.patchValue({\n          title: product.title,\n          description: product.description,\n          price: product.price,\n          priceAfterDiscount: product.priceAfterDiscount || 0,\n          category: product.category._id\n        });\n        this.productColors = [...(product.colors || [])];\n        this.existingCoverImage = product.imageCover;\n        this.existingImages = [...(product.images || [])];\n        // Load sizes and quantities\n        if (product.quantity && product.quantity.length > 0) {\n          this.sizeRows = product.quantity.map(qty => {\n            const masterSize = this.masterSizes.find(s => s.sizeName.toLowerCase() === qty.size.toLowerCase());\n            return {\n              sizeId: (masterSize === null || masterSize === void 0 ? void 0 : masterSize._id) || '',\n              quantity: qty.no\n            };\n          }).filter(row => row.sizeId); // Filter out sizes that don't exist in master sizes\n        }\n\n        this.isLoading = false;\n      },\n      error: error => {\n        console.error('Error loading product:', error);\n        this.isLoading = false;\n        this.notificationService.error('Error', 'Failed to load product');\n        this.router.navigate(['/admin/products']);\n      }\n    });\n  }\n  loadCategories() {\n    this.apiService.getPaginated('/categories', {\n      limit: 100\n    }).subscribe({\n      next: response => {\n        this.categories = response.data || [];\n      },\n      error: error => {\n        console.error('Error loading categories:', error);\n        this.notificationService.error('Error', 'Failed to load categories');\n      }\n    });\n  }\n  loadMasterSizes() {\n    this.apiService.getSingle('/sizes/master').subscribe({\n      next: response => {\n        this.masterSizes = response.data || response || [];\n      },\n      error: error => {\n        console.error('Error loading master sizes:', error);\n        this.notificationService.error('Error', 'Failed to load master sizes');\n      }\n    });\n  }\n  addSizeRow() {\n    this.sizeRows.push({\n      sizeId: '',\n      quantity: 0\n    });\n  }\n  removeSizeRow(index) {\n    this.sizeRows.splice(index, 1);\n  }\n  onCoverImageSelected(event) {\n    const file = event.target.files[0];\n    if (file) {\n      this.selectedCoverImage = file;\n      this.existingCoverImage = null; // Clear existing image when new one is selected\n    }\n  }\n\n  onImagesSelected(event) {\n    const files = Array.from(event.target.files);\n    if (files.length > 0) {\n      this.selectedImages = files;\n    }\n  }\n  addColor() {\n    if (this.newColor && !this.productColors.includes(this.newColor)) {\n      this.productColors.push(this.newColor);\n      this.newColor = '';\n    }\n  }\n  removeColor(color) {\n    this.productColors = this.productColors.filter(c => c !== color);\n  }\n  getImageUrl(imagePath) {\n    if (!imagePath) return '';\n    if (imagePath.startsWith('http')) {\n      return imagePath;\n    }\n    return `${this.uploadsBaseUrl}/products/${imagePath}`;\n  }\n  getImagePreview(file) {\n    if (file) {\n      return URL.createObjectURL(file);\n    }\n    return '';\n  }\n  getQuantityArray() {\n    const quantityArray = [];\n    this.sizeRows.forEach(row => {\n      if (row.sizeId) {\n        const masterSize = this.masterSizes.find(s => s._id === row.sizeId);\n        if (masterSize) {\n          const quantity = row.quantity || 0;\n          quantityArray.push({\n            size: masterSize.sizeName.toLowerCase(),\n            no: quantity\n          });\n        }\n      }\n    });\n    return quantityArray;\n  }\n  onSizeChange(index, event) {\n    const select = event.target;\n    this.sizeRows[index].sizeId = select.value;\n  }\n  onQuantityChange(index, event) {\n    const input = event.target;\n    this.sizeRows[index].quantity = parseInt(input.value) || 0;\n  }\n  saveProduct() {\n    if (this.productForm.valid) {\n      // Validate sizes\n      const quantityArray = this.getQuantityArray();\n      const sizeIds = new Set(quantityArray.map(q => q.size));\n      if (quantityArray.length !== sizeIds.size) {\n        this.notificationService.error('Error', 'Duplicate sizes are not allowed');\n        return;\n      }\n      // Check if sizes exist in master sizes\n      const masterSizeNames = this.masterSizes.map(s => s.sizeName.toLowerCase());\n      const invalidSizes = quantityArray.filter(q => !masterSizeNames.includes(q.size));\n      if (invalidSizes.length > 0) {\n        this.notificationService.error('Error', `Size \"${invalidSizes[0].size}\" does not exist. Please create it first.`);\n        return;\n      }\n      // Validate cover image\n      if (!this.isEditMode && !this.selectedCoverImage) {\n        this.notificationService.error('Error', 'Cover image is required');\n        return;\n      }\n      this.isSaving = true;\n      const formData = new FormData();\n      formData.append('title', this.productForm.value.title);\n      formData.append('description', this.productForm.value.description);\n      formData.append('price', this.productForm.value.price.toString());\n      if (this.productForm.value.priceAfterDiscount) {\n        formData.append('priceAfterDiscount', this.productForm.value.priceAfterDiscount.toString());\n      }\n      formData.append('category', this.productForm.value.category);\n      // Add colors\n      this.productColors.forEach(color => {\n        formData.append('colors', color);\n      });\n      // Add cover image\n      if (this.selectedCoverImage) {\n        formData.append('imageCover', this.selectedCoverImage);\n      }\n      // Add additional images\n      this.selectedImages.forEach(image => {\n        formData.append('images', image);\n      });\n      // Add quantity array as JSON string\n      if (quantityArray.length > 0) {\n        formData.append('quantity', JSON.stringify(quantityArray));\n      }\n      if (this.isEditMode && this.productId) {\n        // Update product\n        this.apiService.putFormData('/product', this.productId, formData).subscribe({\n          next: response => {\n            this.notificationService.success('Success', 'Product updated successfully');\n            this.isSaving = false;\n            this.router.navigate(['/admin/products', this.productId]);\n          },\n          error: error => {\n            var _a;\n            console.error('Error updating product:', error);\n            this.isSaving = false;\n            this.notificationService.error('Error', ((_a = error.error) === null || _a === void 0 ? void 0 : _a.message) || 'Failed to update product');\n          }\n        });\n      } else {\n        // Create product\n        this.apiService.postFormData('/product', formData).subscribe({\n          next: response => {\n            this.notificationService.success('Success', 'Product created successfully');\n            this.isSaving = false;\n            const newProduct = response.data;\n            if (newProduct && newProduct._id) {\n              this.router.navigate(['/admin/products', newProduct._id]);\n            } else {\n              this.router.navigate(['/admin/products']);\n            }\n          },\n          error: error => {\n            var _a;\n            console.error('Error creating product:', error);\n            this.isSaving = false;\n            this.notificationService.error('Error', ((_a = error.error) === null || _a === void 0 ? void 0 : _a.message) || 'Failed to create product');\n          }\n        });\n      }\n    }\n  }\n  cancel() {\n    if (this.isEditMode && this.productId) {\n      this.router.navigate(['/admin/products', this.productId]);\n    } else {\n      this.router.navigate(['/admin/products']);\n    }\n  }\n  getFieldError(fieldName) {\n    var _a, _b, _c;\n    const control = this.productForm.get(fieldName);\n    if (control && control.invalid && (control.dirty || control.touched)) {\n      if ((_a = control.errors) === null || _a === void 0 ? void 0 : _a['required']) {\n        return `${this.getFieldLabel(fieldName)} is required`;\n      }\n      if ((_b = control.errors) === null || _b === void 0 ? void 0 : _b['minlength']) {\n        const minLength = control.errors['minlength'].requiredLength;\n        return `${this.getFieldLabel(fieldName)} must be at least ${minLength} characters`;\n      }\n      if ((_c = control.errors) === null || _c === void 0 ? void 0 : _c['min']) {\n        const min = control.errors['min'].min;\n        return `${this.getFieldLabel(fieldName)} must be at least ${min}`;\n      }\n    }\n    return '';\n  }\n  hasFieldError(fieldName) {\n    const control = this.productForm.get(fieldName);\n    return !!(control && control.invalid && (control.dirty || control.touched));\n  }\n  getFieldLabel(fieldName) {\n    const labels = {\n      title: 'Title',\n      description: 'Description',\n      price: 'Price',\n      priceAfterDiscount: 'Price After Discount',\n      category: 'Category'\n    };\n    return labels[fieldName] || fieldName;\n  }\n};\n__decorate([Input()], ProductFormComponent.prototype, \"productId\", void 0);\nProductFormComponent = __decorate([Component({\n  selector: 'app-product-form',\n  standalone: true,\n  imports: [CommonModule, FormsModule, ReactiveFormsModule, RouterModule],\n  templateUrl: './product-form.component.html',\n  styleUrls: ['./product-form.component.css']\n})], ProductFormComponent);\nexport { ProductFormComponent };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}